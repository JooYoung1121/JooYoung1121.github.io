---
title: "[OS] IPC, CPU스케줄링"
categories: 
  - CS
  - OS
last_modified_at: 2021-05-21T10:00:00+09:00
toc: true
tags: 
  - CS지식
  - OS
  - 면접질문
---

# OS 대비 

## IPC, CPU스케줄링


## **`IPC(Inter Process Communication)`**

프로세스는 독립적으로 실행된다. 즉, 독립되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다. 하지만 쓰레드는 프로세스안에서 자원을 공유하므로 영향을 받는다. 

이런 독립적 구조를 가진 프로세스 간의 통신을 해야하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 IPC 통신이다. 

프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다. 

여기서 **`커널`** 은 운영체제의 핵심적인 부분으로, 다른 모든 부분에 여러 기본적인 서비스를 제공해준다. 

### IPC 종류 
1. **`익명 PIPE`**
- 파이프는 두개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다. 
- 한쪽 방향으로만 통신이 가능한 반이중통신
- 따라서 양쪽으로 모두 송수신 하고 싶으면 2개 파이프 생성
- 매우 간단하게 사용된다는 장점과 단순한 데이터 흐름을 가질 때 파이프를 사용하는것이 효율적이라는 장점이 있다. 
- 하지만 전이중통신을 위해 2개를 만들어야 할때는 구현이 복잡하다. 
2.	**`Named PIPE(FIFO)`**
- 익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용한다. (부모-자식 프로세스 간 통신)
- 전혀 모르는 상태의 프로세스들 사이 통신에 사용
- 즉, 익명 파이프의 확장된 상태로 부모 프로세스와 무관한 다른 프로세스도 통신이 가능
- 하지만 읽기/쓰기 동시 불가-> 따라서 전이중 통신을 위해 2개 만들어야함
3. **`Message Queue`**
- 입출력 방식은 Names PIPE와 동일
- 다른점은 데이터의 흐름이 아니라 메모리 공간
- 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다. 
4. **`공유메모리(Shared Memory)`**
- 파이프, 메시지큐가 통신을 이용한 설비라며나, 공유메모리는 데이터 자체를 공유하도록 지원하는 설비
- 프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근하지 못하도록 반드시 보호되야한다. 하지만 다른 프로세스가 데이터를 사용하도록 해야하는 상황도 필요할 것이다. 파이프를 이용해 통신을 통해 데이터 전달도 가능하지만, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다. 
- 공유 메모리는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용
- 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 
- 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다. 
	
    ◦ 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC중에 가장 빠르게 작동
5. **`메모리 맵`**
- 공유 메모리처럼 메모리를 공유
- 메모리맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식(공유 매게체가 파일 + 메모리)
- 주로 파일로 대용량 데이터를 공유할 때 사용
6. **`소켓`**
- 네트워크 소켓 통신을 통해 데이터를 공유
- 클라이언트와 서버가 소켓을 통해서 통신하는 구조, 원격에서 프로세스 간 데이터를 공유할 때 사용
- 서버(bind, listen, accept), 클라이언트(connect)

이러한 IPC통신에서 프로세스 간 데이터를 동기화하고 보호하기위해 `세마포오`와 `뮤텍스` 사용


## **`CPU 스케쥴링`**
간단하게 요약하면 CPU를 잘 사용하기 위해 프로세스를 잘 배정하는 것 

• 목표
1. Batch System : 가능하면 많은 일을 수행. 시간보단 처리량이 중요
2. Interative System : 빠른 응답 시간. 적은 대기 시간.
3. Real-time System : 기한 맞추기

선점/비선점 스케줄링 
- 선점(Preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
- 비선점(nonpreemptive) : 프로세스 종료 또는 I/O 등의 이벤트가 있을 때까지 실행 보장

### **프로세스 주기**
![Process](https://user-images.githubusercontent.com/37646197/119135202-115c4180-ba79-11eb-8572-d7fc9170590c.PNG)

여기서 비선점 스케줄링은 `Interrupt`와 `Scheduler Dispatch` 에 해당하고 선점 스케줄링은 `I/O or Event Wait` 에 해당한다. 

프로세스 주기를 하나하나 해석해보면 다음과 같다. 

- **`Admitted`** : 프로세스 생성이 가능하여 승인
- **`Scheduler Dispatch`** : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행
- **`인터럽트(Interrupt)`** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것. 
- **`I/O or Event Wait`** : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것 
- **`I/O or Event Completion)`** : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것. 


## **`CPU 스케줄링의 종류`**

- **`비선점 스케줄링`** 
  
  1. FCFS(First Come First Served)
       - 큐에 도착한 순서대로 CPU할당
       - 실생 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐

  2. SJS(Shortest Job First)
        - 수행시간이 가장 짧다고 판단되는 작업 먼저 수행
        - FCFS보다 평균 대기 시간 감소, 짧은 작업에 유리함

- **`선점 스케줄링`**

  1. `Priority Scheduling`

     - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리 
     - 우선 순위가 낮은 프로세스가 무한정 기다리는 Sratvation이 생길 수 있음. 
     - Aging 방법으로 Starvation문제 해결 가능  
    
    ※ Starvation : 자원을 할당받지 못해 굶어 죽는단 표현
    
    ※ Aging : 각 프로세스별로 나이(count)를 해서 오래된 애들은 먼저 우선순위를 부여

    2. `Round Robin`

       - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU를 할당
       - Time Quantum이 크면 FCFS와 같게 되고, 작으면 Context Switching이 잦아져서 오버헤드 증가
       - 즉, 프로세스를 특정 단위로 나눠서 순차적으로 처리하는 것 

    ※ Time Quantum : 실행의 최소 단위 시간


    3. `Multilevel-Queue(다단계 큐)`

        - 작업들을 여러 종류의 그룹으로 나누어 여러개의 큐를 이용하는 기법
        - 우선순위가 낮은 큐들이 실행 못하는걸 방지하고자 각 큐마다 다른 Time Quantum을 설정
        - 우선순위에 맞게 큐에 Time Quantum을 설정함
        - 그림 참조
![MLQ](https://user-images.githubusercontent.com/37646197/119137351-b0823880-ba7b-11eb-8c82-216bae2d0189.PNG)
![MLQ2](https://user-images.githubusercontent.com/37646197/119137373-b6781980-ba7b-11eb-8b9f-8b8f8531baf6.PNG)


  4. `Multilevel-Feddback-Queue(다단계 피드백 큐)`
       - 다단계 큐에서 자신의 Time Quantum을 다 채운 프로세스는 밑으로 내려가고 자신의 TimeQuantum 을 다 채우지 못한 프로세스는 원래 큐 그대로 들어옴.  
       - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
       - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
       - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌
       - 그림 참조
       - ![MLFQ](https://user-images.githubusercontent.com/37646197/119138001-5d5cb580-ba7c-11eb-9f9a-d7fc0abc9197.PNG) 


## Reference 
[Gyoogle](https://gyoogle.dev/blog/computer-science/operating-system/CPU%20Scheduling.html)

