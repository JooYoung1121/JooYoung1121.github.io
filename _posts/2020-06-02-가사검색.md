---
title: "[프로그래머스] 가사검색"
categories: 
  - 프로그래머스
date: 2020-06-02
last_modified_at: 2020-06-02T20:00:00+09:00
toc: true
published : false
tags: 
  - 프로그래머스
  - 알고리즘
  - BFS
  - 해시
  - Map
  - Trie
---

2020 카카오 블라인드 코딩테스트 문제이다. 

**[가사검색](https://programmers.co.kr/learn/courses/30/lessons/60060)**

문제는 다음과 같다. 

![설명](/assets/images/프로그래머스/가사검색_설명.png)
![제한1](/assets/images/프로그래머스/가사검색_제한사항1.png)
![제한2](/assets/images/프로그래머스/가사검색_제한사항2.png)
![입출력](/assets/images/프로그래머스/가사검색_입출력.png)


일단 이 문제는 난 실제 시험에선 절대 못풀었다. 이후 카카오에서 문제 설명을 해주면서 Trie자료구조를 사용해야 한다고 말을 하였고 그때 처음으로 Trie자료구조에 대해서 알게 되었다. 

Trie 레퍼런스로 설명하고 해시에 대해서 설명하면 포스팅 완료

### Trie풀이
```cpp
#include <string>
#include <vector>

using namespace std;

const int NUM = 27;

int toNumber(char n) {
	if (n == '?')
	{
		return 26;
	}

	return n - 'a';
}

struct TrieNode
{
	TrieNode* children[NUM];
	bool terminal;
	int cnt;

	TrieNode() :terminal(false), cnt(0)
	{
		for (int i = 0; i < NUM; ++i)
		{
			children[i] = NULL;
		}
	}

	~TrieNode()
	{
		for (int i = 0; i < NUM; i++)
		{
			if (children[i])
			{
				delete children[i];
			}
		}
	}

	void insert(const char* key)
	{
		//키값이 널이라면
		if (*key == 0)
		{
			terminal = true;
		}
		else
		{
			int next = toNumber(*key);
			if (children[next] == NULL)
			{
				children[next] = new TrieNode();
			}

			children[next]->insert(key + 1);
		}
	}

	void find(const char* key)
	{
		if (*key == 0)
		{
			cnt++;
			return;
		}

		int next = toNumber(*key);
		if (children[toNumber('?')] != NULL)
		{
			children[toNumber('?')]->find(key + 1);
		}

		if (children[next] != NULL)
		{
			children[next]->find(key + 1);
		}
	}

	int getCnt(const char* key)
	{
		if (*key == 0)
		{
			return cnt;
		}

		int next = toNumber(*key);
		if (children[next] == NULL)
		{
			return 0;
		}

		return children[next]->getCnt(key + 1);
	}
};

vector<int> solution(vector<string> words, vector<string> queries) {
	vector<int> answer;

	TrieNode Trie;

	for (int i = 0; i < queries.size(); i++) {
		Trie.insert(queries[i].c_str());
	}

	for (int i = 0; i < words.size(); i++) {
		Trie.find(words[i].c_str());
	}

	for (int i = 0; i < queries.size(); i++) {
		answer.push_back(Trie.getCnt(queries[i].c_str()));
	}

	return answer;
}

```

### 해시 풀이
```cpp
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

bool match(string &query, string &word);

vector<int> solution(vector<string> words, vector<string> queries) {
    unsigned long max_length = 0;

    for (string &word : words) {
        max_length = max(max_length, word.length());
    }

    vector<int> answer;

        for (string &query : queries) {
            int num_matched = 0;

            for (string &word : words) {
                if (match(query, word)) {
                    num_matched++;
                }
            }

            answer.push_back(num_matched);
        }

    return answer;
}

bool match(string &query, string &word) {
    if (query.length() != word.length()) {
        return false;
    }

    for (int i = 0; i < query.length(); ++i) {
        if (query[i] != '?' && query[i] != word[i]) {
            return false;
        }
    }

    return true;
}

```