---
title: "[OS] 메모리"
categories: 
  - CS
  - OS
last_modified_at: 2021-05-26T10:00:00+09:00
toc: true
tags: 
  - CS지식
  - OS
  - 면접대비
---

## **`메모리`**

### **`메인메모리(main memory)`**

    메인 메모리는 CPU가 직접 접근할 수 있는 접근장치이고 프로세스가 실행되려면 프로그램이 메모리에 적재되야한다. 

메인 메모리는 주소가 할당된 일련의 바이트들로 구성되어있다. 

CPU는 레지스터가 지시하는 대로 메모리에 접근하여 다음에 수행할 명령어를 가져온다. -> 이때 명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 우선 가져와야 하는데 이러한 역할을 하는 것이 **`MMU`** 이다. 

![MMU](https://user-images.githubusercontent.com/37646197/119652607-472a6d00-be61-11eb-9057-f1282fde2af6.PNG)

![MMU2](https://user-images.githubusercontent.com/37646197/119652673-61644b00-be61-11eb-858b-b7a04801f00e.PNG)

**`메모리 관리 장치(MMU)`** : 논리주소를 물리주소로 변환 + 메모리보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 **관리**해주는 하드웨어

메모리 공간은 한정적 -> 사용자에게 더 많은 메모리를 제공하기 위해 **`'가상주소'`** 라는 개념 등장

MMU는 이 가상주소에서 실제 데이터가 담겨있는 곳에 접근하기 위해 빠른 주소 변환을 제공

**`캐시`** : 메인 메모리 직접 접근은 비효율적이기 때문에 CPU와 메인메모리 속도를 맞추기 위해 중간에서 중재역할을 하는 공간


### **MMU의 메모리 보호** 

프로세스는 독립적인 메모리 공간을 가져야 되고, 자신의 공간만 접근해야 한다. 

따라서 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 **`trap`** 을 발생시켜 보호

우선 이 부분을 알기 위해선 메모리 구조를 알아야 한다. 


![Memory](https://user-images.githubusercontent.com/37646197/119652081-a3d95800-be60-11eb-8123-47d26454e1f2.PNG)


**`base 레지스터`** : 메모리상의 프로세스 시작 주소를 물리 주소로 저장

**`limit 레지스터`** : 프로세스의 사이즈를 저장 

![Memory2](https://user-images.githubusercontent.com/37646197/119652305-dedb8b80-be60-11eb-8447-c872f5ec4959.PNG)

즉, 메모리값이 base를 넘거나 같고 base + limit값을 초과한다면 trap을 발생시키는 것이다. 

안정성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계한다. -> 사용자 모드에서 변경해서 문제가 생길것을 방지

### 페이지 교체
    메모리 과할당이 발생했을 때, 프로세스 하나를 swap out 해서 빈 프레임을 확보하는 것 

1. 프로세스 실행 도중 페이지 부재 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리에 빈 프레임이 있는지 확인
    - 빈 프레임이 있으면 해당 프레임 사용
    - 없다면, victim 프레임을 선정해 디스크에 기록하고 페이지 테이블 업데이트 -> 페이지 교체 알고리즘 

4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트 

페이지 교체가 이루어지면 아무일이 없던 것처럼 프로세스는 계속 수행 -> 사용자는 알지 못함 

-> 이게 가능하려면 사용에 있어서 부하가 많이 발생하면 안됨 -> 즉, **`오버헤드`** 가 많이 발생하면 안된다 .

![page1](https://user-images.githubusercontent.com/37646197/119653790-b785be00-be62-11eb-8bca-2dc01474cf79.PNG)

![page2](https://user-images.githubusercontent.com/37646197/119653796-b81e5480-be62-11eb-8e80-998651f3cba7.PNG)

![page3](https://user-images.githubusercontent.com/37646197/119653800-b8b6eb00-be62-11eb-9424-cd6ef4fa6f57.PNG)


### **오버헤드 감소**

빈 프레임이 없는 상황에서 victim 프레임을 비울 때와 원하는 페이지를 프레임으로 올릴 때 **`두번의 디스크 접근`** 이 이루어진다. 

페이지 교체가 많이 이루어지면, 이처럼 입출력 연산이 많이 발생하게 되면서 **`오버헤드`** 문제 발생 

1. 변경 비트를 모든 페이지마다 둬서, victim 페이지가 정해지면 해당 페이지의 비트 확인 -> 해당 비트값에 따라서 페이지내용이 디스크상 페이지 내용과 달라졌는지 아닌지를 판단해서 불필요한 오버헤드 줄이는 방법

2. 페이지 교체 알고리즘을 상황에 맞게 선택하여서 페이지 폴트 확률을 감소시킴


## **`캐시메모리`**

- 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
- CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위한 방법


CPU가 이미 봤던 걸 다시 재접근할 때, 메모리 참조 및 인출 과정에 대한 비용을 줄이기 위해 캐시에 저장해둔 데이터 활용. 

### **CPU와 기억장치의 상호작용**

CPU에서 주소 전달 -> 캐시에 명령이 존재하는지 확인

- 존재 한다면 Hit -> 해당 명령어를 CPU로 전송 
- 존재하지 않는다면 Miss -> 명령어를 가지고 주기억장치로 접근 -> 해당 명령어를 가진 데이터 인출 -> 해당 명령어 데이터를 캐시에 저장 -> 해당 명령어를 CPU로 전송 


이러한 캐시메모리의 원리는 지역성의 원리(Locality)에서 비롯된다. 

**`지역성(Locality)`** : 기억 장치 내의 정보를 균일하게 접근하기 보단 특정 순간이나 특정 공간에 집중적으로 참조하는 특성

**시간 지역성** : 최근 참조된 주소의 내용은 또 다시 참조될 가능성이 높다. 

**공간 지역성** : 최근 참조된 프로그램의 주소와 인접한 주소를 가진 내용이 참조될 가능성이 높다. 


## Summary 

- 공부하면서 느낀거지만 새로운 개념도 많이 알기도 하고 기존에 알던 내용을 다시 리마인드 해서 좋은 것 같다. 

## Reference 
[Gyoogle](https://gyoogle.dev/blog/computer-science/operating-system/Memory.html)

[OS강의(공룡책)](https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98/dashboard)